# ГЛАВА 1

# ТРЕБОВАНИЯ К ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ (SOFTWARE REQUIREMENTS)

### АКРОНИМЫ (ACRONYMS)
|        |                                              |                                               |
|--------|----------------------------------------------|-----------------------------------------------|
| ATDD   | Acceptance Test Driven Development           | Разработка, управляемая приемочными тестами   |
| BDD    | Behavior Driven Development                  | Разработка, управляемая поведением            |
| CIA    | Confidentiality, Integrity, and Availability | Конфиденциальность, целостность и доступность |
| FSM    | Functional Size Measurement                  | Измерение функционального размера             |
| INCOSE | International Council on Systems Engineering | Международный совет по системной инженерии    |
| JAD    | Joint Application Development                | Совместная разработка приложений              |
| JRP    | Joint Requirements Planning                  | Совместное планирование требований            |
| RUP    | Rational Unified Process                     | Рациональный унифицированный процесс          |
| SME    | Subject Matter Expert                        | Эксперт по предметной области                 |
| SysML  | Systems Modeling Language                    | Язык моделирования систем                     |
| TDD    | Test Driven Development                      | Разработка, управляемая тестами               |
| UML    | Unified Modeling Language                    | Унифицированный язык моделирования            |
| KA     | Knowledge areas                              | Область знаний                                |


## ВВЕДЕНИЕ (INTRODUCTION)

Требования к программному обеспечению следует рассматривать с двух точек зрения. Первая - как выражение потребностей и ограничений программного продукта или проекта, которые способствуют решению проблемы реального мира. Вторая - это деятельность, необходимая для разработки и поддержки требований к программному продукту и проекту, который его создает. Обе точки зрения представлены в этой области знаний (ОЗ).

Если команда плохо справляется с определением требований, проект, продукт или оба продукта, скорее всего, пострадают от дополнительных затрат, задержек, отмены и дефектов. Одна из причин заключается в том, что каждое требование к программному продукту обычно приводит к принятию множества проектных решений. Каждое проектное решение обычно приводит к множеству решений на уровне кода. Каждое решение может включать в себя и несколько решений по тестированию. Другими словами, правильное определение требований - это работа с высокими ставками. Если не обнаружить и не исправить их на ранней стадии, то отсутствующие, неверно истолкованные и неправильные требования могут привести к экспоненциальному каскаду переделок для их исправления.

Реальные программные проекты, как правило, страдают от двух основных проблем, связанных с требованиями:

1. неполнота: существуют требования заинтересованных сторон, которые не раскрыты и не доведены до сведения инженеров-программистов;

2. двусмысленность: требования передаются в форме, допускающей множество интерпретаций, при этом только одна из возможных интерпретаций является правильной.

Помимо очевидной краткосрочной роли, которую требования играют в первоначальном создании программного обеспечения, они также играют менее признанную, но все же важную роль в долгосрочном сопровождении. Получив программное обеспечение без какой-либо сопроводительной документации, инженер-программист имеет несколько способов определить, что делает этот код, например, выполнить его, пройтись по нему отладчиком, выполнить его вручную, статически проанализировать его и так далее. Сложность заключается в определении того, для чего предназначен этот код. То, что обычно называют ошибкой *(bug)*, но правильнее называть дефектом *(defect)*, - это просто наблюдаемое расхождение между тем, что должно делать программное обеспечение, и тем, что оно делает. Роль документации по требованиям на протяжении всего срока службы программного обеспечения заключается в том, чтобы фиксировать и передавать намерения инженеров-программистов, которые поддерживают код, но, возможно, не были его первоначальными авторами.

Раздел <a href="/1_Software Requirements.markdown">"Требования к программному обеспечению"</a> касается разработки требований к программному обеспечению и управления этими требованиями на протяжении всего срока службы программного обеспечения. Этот раздел обеспечивает понимание того, что требования к программному обеспечению:

- не обязательно являются отдельным видом деятельности на переднем этапе жизненного цикла разработки программного обеспечения, а скорее представляют собой процесс, начатый в начале проекта, который часто продолжает уточняться в течение всего срока службы программного обеспечения;
- должны быть адаптированы к условиям организации и проекта.

Термин "инженерия требований" часто используется для обозначения систематической работы с требованиями. Для единообразия термин "инженерия" не будет использоваться в данном разделе, кроме как для обозначения программной инженерии как таковой.

Раздел <a href="/1_Software Requirements.markdown">"Требования к ПО"</a> наиболее тесно связан с разделом <a href="/2_Software Architecture.markdown">"Архитектура ПО"</a>, <a href="/3_Software Design.markdown">"Проектирование ПО"</a>, <a href="/4_Software Construction.markdown">"Конструирование ПО"</a>, <a href="/5_Software Testing.markdown">"Тестирование ПО"</a> и <a href="">"Сопровождение ПО"</a>, а также с темой <a href="">"Модели"</a> в разделе <a href="">"Модели и методы программной инженерии"</a> в том смысле, что спецификация требований в форме модели может иметь высокую ценность.

Этот раздел также связан с темой <a href="">"Жизненные циклы программного обеспечения"</a> в <a href="">"Процесс программной инженерии"</a>, поскольку этот раздел сосредоточен на том, что и как можно и нужно делать в работе над требованиями, в то время как жизненный цикл проекта определяет, когда эта работа выполняется. Например, при каскадном жизненном цикле вся работа над требованиями, по сути, выполняется на отдельной фазе "Требования" , и ожидается, что она будет в значительной степени завершена до начала работ по архитектуре, проектированию и строительству на последующих фазах . В некоторых итеративных жизненных циклах первоначальная работа над требованиями высокого уровня выполняется на этапе Inception, а дальнейшая детализация - на одном или нескольких этапах Elaboration. В жизненном цикле Agile работа над требованиями ведется постепенно, точно в срок, по мере создания каждого дополнительного элемента функциональности.

Что и как в работе над требованиями к программному обеспечению на проекте должно определяться природой создаваемого программного обеспечения, а не жизненным циклом, в рамках которого оно создается. В той мере, в какой документация по требованиям фиксирует и передает замысел программного обеспечения, последующие сопровождающие не должны быть в состоянии определить жизненный цикл, использованный в предыдущей разработке, только по форме этих требований.

Этот раздел также связан, но в несколько меньшей степени, с разделом по <a href="/8_Software Configuration Management.markdown">"управлению конфигурацией ПО"</a>, <a href="">"управлению программной инженерией"</a> и <a href="">"качеству ПО"</a>. Подходы КМ ПО могут применяться для отслеживания и управления требованиями; качество ПО смотрит на то, насколько хорошо сформированы требования, а инженерное управление может использовать состояние требований для оценки завершения проекта.

## РАЗБИВКА ТЕМ ДЛЯ ТРЕБОВАНИЙ К ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ (BREAKDOWN OF TOPICS FOR SOFTWARE REQUIREMENTS)

Разбивка тем для раздела <a href="/1_Software Requirements.markdown">"Требования к программному обеспечению"</a> показана на рисунке 1.1.

<div style="text-align:center">
<img src="Images/Chapter 1/Рисунок 1.1. Разбивка тем по требованиям к программному обеспечению.bmp"
alt="Рисунок 1.1. Разбивка тем по требованиям к программному обеспечению.">
<br>Рисунок 1.1. Разбивка тем по требованиям к программному обеспечению.
</div>


### 1 ОСНОВЫ ТРЕБОВАНИЙ К ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ (SOFTWARE REQUIREMENTS FUNDAMENTALS)

#### 1.1 Определение требования к программному обеспечению (Definition of a Software Requirement)

Формально требование к программному обеспечению определяется как:

- условие или возможность, необходимые пользователю для решения проблемы или достижения цели;
- условие или возможность, которым должна соответствовать система или системный компонент, чтобы соответствовать контракту, стандарту, спецификации или другому официально установленному документу.;
- документально подтвержденное представление или возможность, как указано в
(1) или (2) выше.

Это формальное определение расширяется в данном разделе, чтобы включить выражения потребностей и ограничений программного проекта.

В самом общем виде требование к программному обеспечению - это свойство, которое должно быть продемонстрировано для решения реальной проблемы. Оно может быть направлено на полную или частичную автоматизацию задачи, поддерживающей бизнес-политику и процессы организации, исправление недостатков существующего программного обеспечения или управление устройством - это лишь некоторые из множества проблем, для которых возможны программные решения.

Бизнес-политики и процессы, а также функции устройств часто бывают очень сложными. В свою очередь, требования к программному обеспечению часто представляют собой сложную комбинацию требований от различных заинтересованных сторон на разных организационных уровнях, которые вовлечены или связаны с некоторыми аспектами среды, в которой будет работать программное обеспечение.

Обычно требования предъявляют клиенты, заказчики и пользователи. Однако другие третьи стороны, такие как регулирующие органы и, в некоторых случаях, организация, разрабатывающая программное обеспечение, или сам проект, также могут предъявлять требования.

#### 1.2 Категории требований к программному обеспечению (Categories of Software Requirements)

На рисунке 1.2 показаны категории требований к программному обеспечению, определенные в данном руководстве, и взаимосвязи между этими категориями. Далее приводится описание каждой категории.

<div style="text-align:center">
<img src="Images/Chapter 1/Рисунок 1.2. Категории требований к программному обеспечению.bmp"
alt="Рисунок 1.2. Категории требований к программному обеспечению.">
<br>Рисунок 1.2. Категории требований к программному обеспечению.
</div>

#### 1.3 Требования к программному продукту и программному обеспечению Требования к проекту (1.3.Software Product Requirements and Software Project Requirements)

Требования к программному продукту определяют ожидаемую форму, соответствие или функциональность программного обеспечения. Требования к проекту программного обеспечения, также называемые требованиями к процессу или, иногда, бизнес—требованиями, ограничивают проект, в рамках которого создается программное обеспечение. Требования к проекту часто ограничивают затраты, график и/или штат сотрудников, но также могут влиять на другие аспекты проекта по разработке программного обеспечения, такие как среда тестирования, перенос данных, обучение пользователей и техническое обслуживание. Требования к проекту по разработке программного обеспечения могут быть отражены в уставе проекта или другом документе высокого уровня, посвященном началу проекта. Они наиболее важны для управления проектом (см. раздел <a>"Управление разработкой программного обеспечения"</a>) или для определения того, какой процесс жизненного цикла следует использовать (см. раздел <a>"Процесс разработки программного обеспечения"</a>). В этом разделе требования к проекту программного обеспечения далее не рассматриваются.

#### 1.4 Функциональные требования (Functional Requirements)

Функциональные требования определяют наблюдаемое поведение, которое должно обеспечивать программное обеспечение — политики, которые должны применяться, и процессы, которые должны выполняться. Примерами политик в банковском программном обеспечении могут быть “владельцем счета всегда должен быть по крайней мере один клиент” и “баланс счета никогда не должен быть отрицательным”. Например, процессы могут определять значения внесения денег на счет, снятия денег со счета и перевода денег с одного счета на другой.

Даже высокотехничное (не ориентированное на бизнес) программное обеспечение, такое как программное обеспечение, реализующее протокол сетевых коммуникаций Transmission Control Protocol/Internet Protocol (TCP/IP), имеет политики и процессы: “Порт должен иметь возможность существовать с нулем, одним или многими связанными соединениями, но соединение должно существовать на ровно один связанный порт”, “допустимыми состояниями соединения должны быть ”прослушивание“, ”отправка syn", "установлено", "закрытие"..." и "если время жизни сегмента достигает нуля, этот сегмент должен быть удален".

#### 1.5 Нефункциональные требования (Nonfunctional Requirements)

Нефункциональные требования некоторым образом ограничивают технологии, которые будут использоваться при реализации: какие вычислительные платформы? Какой движок базы данных? Насколько точными должны быть результаты? Как быстро должны быть представлены результаты? Сколько записей определенного типа необходимо сохранить? Некоторые нефункциональные требования могут быть связаны с работой программного обеспечения. (Смотрите руководство по эксплуатации и техническому обслуживанию)

Нефункциональные требования можно далее разделить на технологические ограничения и ограничения качества обслуживания.

#### 1.6 Технологические ограничения (Technology Constraints)

Эти требования предписывают — или запрещают — использование конкретных, поименованных технологий автоматизации или определенных инфраструктур. Примерами могут служить требования к использованию определенных вычислительных платформ (например, Windows ™ , macOS ™ , Android OS ™ , iOS ™ ), языков программирования (например, Java, C++, C#, Python), совместимости с определенными веб-браузерами (например, Chrome ™ , Safari ™ , Edge ™ ), а также ядра баз данных (например, Oracle ™ , SQL Server ™ , MySQL ™ ) и общие технологии (например, компьютер с сокращенным набором команд (RISC), реляционная база данных). Другим примером может служить требование, запрещающее использование указателей.

#### 1.7 Ограничения, связанные с качеством обслуживания (Quality of Service Constraints)

Эти требования не ограничивают использование конкретных поименованных технологий. Вместо этого они определяют приемлемые уровни производительности, которые должно демонстрировать автоматизированное решение. Примерами могут служить время отклика, пропускная способность, точность, надежность и масштабируемость. ISO/IEC 25010: “Разработка систем и программного обеспечения – требования и оценка качества систем и программного обеспечения (SQuaRE) – Модели качества систем и программного обеспечения” содержит большой список видов качества обслуживания, которые могут быть актуальны для программного обеспечения. Безопасность также является особенно важной темой, требования к которой, как правило, игнорируются. (Подробнее о конкретных требованиях безопасности, которые следует учитывать, смотрите в разделе "Безопасность")

#### 1.8 Зачем классифицировать требования таким образом? (Why Categorize Requirements This Way?)

Категоризация требований таким образом полезна по следующим причинам:

- требования в одной категории, как правило, поступают из других источников, чем в других категориях;
- методы элайсинга часто различаются в зависимости от источника;
- методы анализа зависят от категории;
- методы спецификации различаются по категориям;
- органы по проверке различаются по категориям;
- различные категории по-разному влияют на результирующее программное обеспечение.

Кроме того, организация требований по этим категориям полезна в следующих отношениях:

- Можно лучше управлять сложностью, поскольку различные области можно рассматривать отдельно; инженеры-программисты могут заниматься политикой и сложностями процессов, не беспокоясь одновременно о проблемах технологии автоматизации (и наоборот). Одна большая проблема превращается в две маленькие. Это классическое управление сложностью по принципу "разделяй и властвуй";
- Различные области экспертизы могут быть изолированы; заинтересованные стороны, а не инженеры-программисты, являются экспертами в политике и процессах, подлежащих автоматизации. Инженеры-программисты, а не заинтересованные стороны, являются экспертами в области технологий. Когда бизнес-эксперту предоставляют для проверки или подтверждения перемежающиеся функциональные и нефункциональные требования, он может отказаться от работы, поскольку не понимает технологических вопросов или даже не интересуется ими. Соответствующие требования

Эксперт может сосредоточиться только на подмножестве релевантных для него требований.

Фильтр идеальных технологий помогает отделить функциональные требования от нефункциональных. Проще говоря, функциональные требования - это те, которые все равно нужно было бы сформулировать, даже если бы существовал компьютер с бесконечной скоростью, неограниченной памятью, нулевой стоимостью, отсутствием сбоев и т. д., на котором можно было бы построить программное обеспечение. Все остальные требования к программному продукту являются ограничениями на технологии автоматизации и, следовательно, нефункциональны.

Большие системы часто охватывают более одной предметной области, или домена. Рекурсивное проектирование показывает, как нефункциональные требования в родительской области могут стать или вызвать функциональные требования в дочерней области. Например, нефункциональное требование к безопасности пользователей в родительском банковском домене может стать или вызвать функциональные требования в дочернем домене безопасности. Аналогично, сквозные нефункциональные требования к аудиту и управлению транзакциями в родительском банковском домене могут стать или вызвать функциональные требования в дочернем домене аудита и дочернем домене транзакций. Декомпозиция больших систем на набор связанных доменов значительно снижает сложность.

#### 1.9 Системные требования и программное обеспечение; Требования (1.9.System Requirements and Software Requirements)

Международный совет по системной инженерии (INCOSE) определяет систему как "взаимодействующую комбинацию элементов для достижения определенной цели. К ним относятся аппаратные средства, программное обеспечение, микропрограммное обеспечение, люди, информация, методы, средства, услуги и другие вспомогательные элементы".

В некоторых случаях полезно или обязательно отличать системные требования от требований к программному обеспечению. Системные требования относятся к более крупным системам - например, к автономному транспортному средству. Требования к программному обеспечению относятся только к элементу программного обеспечения в этой более крупной системе. Некоторые требования к программному обеспечению могут быть получены из системных требований. В других случаях программное обеспечение само по себе является интересующей нас системой, а аппаратное обеспечение и система поддержки рассматриваются как платформа или инфраструктура, так что системные требования в основном являются требованиями к программному обеспечению.

#### 1.10 Производные требования (Derived Requirements)

На практике требования могут быть контекстно-зависимыми и зависеть от перспективы. Внешняя заинтересованная сторона может выдвинуть требование к объему, и это будет требованием для всего проекта - даже если в нем участвуют сотни инженеров-программистов. Решение архитектора использовать стиль архитектуры "трубы и фильтры" не будет требованием с точки зрения всех заинтересованных сторон проекта, а будет проектным решением. Но это же решение, если рассматривать его с точки зрения подгруппы, ответственной за создание конкретного фильтра, будет считаться требованием.

В аэрокосмической промышленности уже давно используется термин "производное требование", означающий требование, которое не было выдвинуто заинтересованными сторонами, не входящими в общий проект, а было навязано внутри большой команды разработчиков. Решение архитектора о трубах и фильтрах подходит под это определение. С точки зрения внешних заинтересованных сторон этот выбор рассматривается как проектное решение, но для подкоманд, ответственных за разработку каждого фильтра, он является требованием.

#### 1.11 Деятельность по разработке требований к программному обеспечению (Software Requirements Activities)

На рисунке 1.3 показана деятельность по разработке и управлению требованиями.

<div style="text-align:center">
<img src="Images/Chapter 1/Рисунок 1.3. Деятельность по разработке требований к программному обеспечению.bmp"
alt="Рисунок 1.3. Деятельность по разработке требований к программному обеспечению.">
<br>Рисунок 1.3. Деятельность по разработке требований к программному обеспечению.
</div>

<br>Разработка требований в целом может рассматриваться как "достижение соглашения о том, какое программное обеспечение должно быть создано". В отличие от этого, управление требованиями можно рассматривать как "поддержание этого соглашения во времени". Каждый вид деятельности представлен в этом разделе. Деятельность по разработке требований представлена в виде отдельных тем, а управление требованиями - в виде отдельной темы.

### 2 ВЫЯВЛЕНИЕ ТРЕБОВАНИЙ (REQUIREMENTS ELICITATION)

Цель выявления требований - выявить требования к кандидатам. Это также называется сбором требований, обнаружением требований или сбором информации о требованиях. Как указывалось ранее, одной из проблем при разработке требований к реальным программным проектам является неполнота. Это может быть результатом неадекватного выявления. Хотя нет гарантии, что набор требований является полным, грамотно выполненный поиск помогает свести к минимуму неполноту.

#### 2.1 Источники требований (Requirements Sources)

Требования поступают — и могут быть получены — из множества различных источников. Все потенциальные источники требований должны быть определены и оценены. Заинтересованную сторону можно определить как любое лицо, группу или организацию, которые:

- активно участвуют в проекте;
- зависят от результатов проекта;
- может повлиять на результат проекта.

Типичные заинтересованные стороны в проектах по разработке программного обеспечения включают, но не ограничиваются ими, следующее:

- клиенты — те, кто платит за разработку программного обеспечения (например, руководство организации);
- клиенты — те, кто решает, будет ли программный продукт введен в эксплуатацию.;
- пользователи — те, кто прямо или косвенно взаимодействует с программным обеспечением; пользователей часто можно разделить на различные классы пользователей, которые различаются по частоте использования, выполняемым задачам, уровню навыков и знаний, уровню привилегий и т.д.;
- эксперты в данной области (МСП);
- операционный персонал;
- сотрудники службы поддержки продукта первого уровня;
- соответствующие профессиональные организации;
- регулирующие органы;
- группы с особыми интересами;
- люди, которые могут пострадать в случае успеха проекта;
- разработчики.

Классы заинтересованных сторон - это группы заинтересованных сторон, которые имеют схожие взгляды и потребности. Работа над программным проектом с точки зрения классов заинтересованных сторон, а не с отдельными заинтересованными сторонами, может дать важную дополнительную информацию.

Многим проектам выгодно проводить анализ заинтересованных сторон, чтобы выявить как можно больше важных категорий заинтересованных сторон. Это снижает вероятность того, что требования будут направлены в сторону более широко представленных заинтересованных сторон и в сторону менее широко представленных заинтересованных сторон. Анализ заинтересованных сторон также может помочь в проведении переговоров и разрешении конфликтов, когда требования одного класса заинтересованных сторон вступают в противоречие с требованиями другого.

Требования не ограничиваются только требованиями людей. Другие источники требований, не относящиеся к персонам, могут включать:

- документация, такая как требования к предыдущим версиям, формулировки задач, концепция операций;
- другие системы;
- более широкий бизнес-контекст, включая организационные политики и процессы;
- вычислительная среда.

#### 2.2 Методы выявления общих требований (Common Requirements Elicitation Techniques)

Для выяснения требований заинтересованных сторон можно использовать широкий спектр методов. Некоторые методы лучше работают с определенными категориями заинтересованных сторон, чем другие. К наиболее распространенным методам выявления заинтересованных сторон относятся следующие:

- интервью;
- встречи, возможно, включая мозговой штурм;
- совместная разработка приложений (JAD), совместное планирование требований (JRP) и другие семинары по содействию;
- анализ протоколов;
- фокус-группы
- анкетирование и обзоры рынка
- поисковое прототипирование, включая создание прототипов пользовательского интерфейса с низкой и высокой точностью;
-  отображение пользовательских историй.


Поиск информации может быть затруднен, и инженер-программист должен знать, что (например) пользователи могут испытывать трудности с описанием своих задач, оставлять важную информацию неустановленной или не желать или не иметь возможности сотрудничать. Поиск информации - это не пассивная деятельность. Даже при наличии заинтересованных сторон, готовых к сотрудничеству и четко сформулированных, инженер-программист должен приложить немало усилий, чтобы получить нужную информацию. Многие требования к продукту являются неявными или могут быть найдены только в информации, которую еще предстоит собрать.

Требования также могут быть получены из источников, отличных от заинтересованных сторон. К таким источникам и методам относятся следующие:

- предыдущие версии системы;
- база данных отслеживания дефектов для предыдущих версий системы;
- системы, которые взаимодействуют с разрабатываемой системой;
- сравнительный анализ конкурентов;
- поиск литературы;
- Управление качеством в рамках внедрения функций контроля качества (QFD);
- наблюдение, при котором инженер-программист изучает работу и среду, в которой она выполняется;
- стажировка, при которой инженер-программист учится, выполняя работу;
- описание сценариев использования;
- декомпозиция (например, возможности делятся на эпические, функциональные возможности - на истории).;
- анализ задач;
- дизайн-мышление (сопереживать, определять, придумывать, создавать прототипы, тестировать);
- ISO/IEC 25010: “Разработка систем и программного обеспечения – Требования и оценка качества систем и программного обеспечения (SQuaRE) – Модели качества систем и программного обеспечения”;
- требования к безопасности, рассмотренные в руководстве по безопасности;
- применимые стандарты и предписания.

### 3 АНАЛИЗ ТРЕБОВАНИЙ (REQUIREMENTS ANALYSIS)

Требования вряд ли будут представлены в окончательном виде. Обычно требуется дальнейшее исследование, чтобы выявить все истинные требования, вытекающие из первоначально полученной информации. Анализ требований помогает разработчикам программного обеспечения понять значение и последствия требований к кандидатам как по отдельности, так и в контексте общего набора требований.

#### 3.1 Анализ основных требований (Basic Requirements Analysis)

приводимый ниже список желательных свойств требований может служить руководством для базового анализа требований. Инженер-программист стремится определить любое из этих свойств, которое еще не выполнено. Каждое требование должно быть:

- однозначным (интерпретируемым только одним способом).;
- поддается проверке (количественной оценке), что означает, что соответствие или несоблюдение требований может быть четко продемонстрировано;
- является обязательным, что означает, что клиенты готовы платить за это и не желают отказываться от этого;
- отражает истинные потребности заинтересованных сторон;
- использует терминологию заинтересованных сторон;
- быть приемлемым для всех заинтересованных сторон.


Общий набор требований должен быть:

- полным, — требования надлежащим образом учитывают граничные условия, условия исключения и требования безопасности;
- внутренне согласованным — Ни одно требование не вступает в противоречие с каким-либо другим;
- внешне согласованным — ни одно требование не вступает в противоречие с каким-либо исходным материалом;
- выполнимо — можно создать жизнеспособное и экономически эффективное решение с учетом затрат, графика, штата сотрудников и других ограничений.


В некоторых случаях полученное утверждение представляет собой решение, которое необходимо реализовать, а не истинную проблему, которую необходимо решить. Это может привести к реализации неоптимального решения. Методика “5 причин” предполагает многократный вопрос: "Почему это является обязательным требованием?", чтобы приблизиться к истинной проблеме. Повторение прекращается, когда ответ звучит так: “Если этого не сделать, значит, проблема заинтересованной стороны не решена”. Часто истинная проблема решается за два или три цикла, но этот метод называется "5 причин", чтобы стимулировать инженеров продвигаться как можно дальше.

#### 3.2 Экономические ограничения качества обслуживания (Economics of Quality of Service Constraints)

Ограничения качества обслуживания могут быть особенно сложными. Как правило, это связано с тем, что инженеры не рассматривают их с экономической точки зрения. Рисунок 1.4 иллюстрирует экономическую перспективу типичных ограничений качества обслуживания, таких как пропускная способность и надежность, где ценность возрастает с повышением уровня производительности. Эта кривая отражается вертикально для ограничений качества обслуживания, значение которых уменьшается по мере повышения уровня производительности (примерами могут служить время отклика и среднее время ремонта).

<div style="text-align:center">
<img src="Images/Chapter 1/Рисунок 1.4. Ценность в зависимости от уровня производительности.bmp"
alt="Рисунок 1.4. Ценность в зависимости от уровня производительности.">
<br>Рисунок 1.4. Ценность в зависимости от уровня производительности.
</div>

<br>
В соответствующем диапазоне уровней эффективности заинтересованные стороны получают соответствующую оценку, если система работает на этом уровне. На кривой оценки есть две важные точки:

1. Точка совершенства — это наиболее благоприятный уровень эффективности, за пределами которого нет дополнительной выгоды. Даже если система может работать лучше, чем на уровне совершенства, клиент не сможет использовать эти возможности. Например, система социальных сетей, которая поддерживает больше пользователей, чем население мира, будет обладать избыточными возможностями.
2. Точка сбоя — это наименее благоприятный уровень производительности, за пределами которого дальнейшее снижение прибыли невозможно. Например, системе социальных сетей может потребоваться поддерживать хотя бы минимальную долю рынка, чтобы быть жизнеспособной в качестве платформы.


Количественный уровень требований, даже если он указан явно, обычно является произвольным. Он часто основывается на том, что клиент считает обоснованным запросить, учитывая, сколько он платит за программное обеспечение. Даже если разработчики программного обеспечения не могут создать систему, полностью отвечающую заявленным требованиям, программное обеспечение, как правило, все равно имеет ценность; просто оно менее ценно, чем ожидал клиент. Кроме того, в некоторых случаях возможность превысить требования может значительно повысить ценность.

Затраты на достижение заданного уровня производительности обычно являются ступенчатой функцией. Во-первых, для данного уровня инвестиций существует некоторый максимально достижимый уровень производительности. Затем требуются дополнительные инвестиции, и эти дополнительные инвестиции позволяют повысить производительность до нового, более благоприятного максимума. На рисунке 1.5 показан наиболее рентабельный уровень производительности - уровень производительности с максимальной положительной разницей между значением на этом уровне производительности и затратами на его достижение.

<div style="text-align:center">
<img src="Images/Chapter 1/Рисунок 1.5. Наиболее экономичный уровень производительности.bmp"
alt="Рисунок 1.5. Наиболее экономичный уровень производительности.">
<br>Рисунок 1.5. Наиболее экономичный уровень производительности.
</div>

<br>
Инженер-программист должен обращать особое внимание на положительные и отрицательные взаимосвязи между ограничениями качества обслуживания. Некоторые ограничения, связанные с качеством обслуживания, являются взаимоподдерживающими; повышение уровня производительности одного из них автоматически повышает уровень производительности другого. Например, чем более модифицируемым является код, тем более надежным он становится, поскольку и модифицируемость, и надежность в определенной степени зависят от того, насколько чистым является код. С другой стороны, чем выше скорость кода, тем менее он может быть изменяемым, поскольку высокая скорость часто достигается за счет оптимизации, которая усложняет код.

#### 3.3 Формальный анализ (Formal Analysis)

Формальный анализ показал преимущества в некоторых прикладных областях, особенно в системах с высокой степенью целостности . Формальное выражение требований зависит от использования языка спецификации с формально определенной семантикой. Формальность имеет два преимущества. Во-первых, формальные требования являются точными и сжатыми, что (в принципе) снижает вероятность неправильного толкования. Во-вторых, формальные требования могут быть обоснованы, что позволяет доказать желаемые свойства указанного программного обеспечения. Это позволяет проводить статическую проверку того, что программное обеспечение, указанное в требованиях, действительно обладает свойствами (например, отсутствием взаимоблокировки), которые ожидают от него заказчик, пользователи и инженер-программист.

Этот раздел относится к формальным методам в разделе Модели и методы разработки программного обеспечения.

#### 3.4 Устранение противоречий в требованиях (Addressing Conflict in Requirements)

Когда в проекте участвует больше заинтересованных сторон, вероятность возникновения конфликтов между требованиями возрастает. Одним из особенно важных аспектов анализа требований является выявление таких конфликтов и управление ими. Как только будут выявлены противоречивые требования, инженер может рассмотреть два различных подхода к управлению этим конфликтом (и, возможно, также другие подходы) и определить наиболее подходящий курс действий.

Один из подходов заключается в согласовании решения между конфликтующими сторонами. В большинстве случаев инженеру-программисту неразумно принимать одностороннее решение, поэтому возникает необходимость проконсультироваться с заинтересованными сторонами для достижения консенсусного решения. По контрактным соображениям часто также важно, чтобы такие решения были доведены до сведения заказчика. Конкретным примером может служить управление масштабом проекта, а именно установление баланса между желаемым в заявленных требованиях к программному продукту и тем, что может быть достигнуто с учетом требований проекта к стоимости, графику, персоналу и другим ограничениям на уровне проекта. Существует множество полезных источников информации о переговорах и разрешении конфликтов.

Другой подход заключается в разработке семейства продуктов. Это предполагает разделение требований на две категории. Первая категория содержит неизменяемые требования. Это требования, с которыми согласны все заинтересованные стороны. Вторая категория содержит различные требования, в которых существует конфликт. Инженер-программист может сосредоточиться на понимании диапазона вариаций, необходимых для удовлетворения всех заинтересованных сторон. Программное обеспечение может быть разработано с использованием design to invariants для соответствия неизменным требованиям и design for change для включения точек настройки для настройки экземпляра системы таким образом, чтобы он наилучшим образом соответствовал соответствующим заинтересованным сторонам. В качестве простого примера, некоторые пользователи погодного приложения требуют, чтобы температура отображалась в градусах Цельсия, в то время как другие - в градусах Фаренгейта.

### 4 ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ (REQUIREMENTS SPECIFICATION)

Спецификация требований касается записи требований таким образом, чтобы их можно было как запомнить, так и донести до общественности. Спецификация требований, возможно, является наиболее спорной темой в этом разделе. Дискуссия сосредоточена на таких вопросах, как:

- должны ли требования вообще быть записаны?
- если требования записаны, то в какой форме они должны быть представлены?
- если требования изложены в письменном виде, должны ли они также поддерживаться в рабочем состоянии?

Стандартных ответов на эти вопросы не существует; ответ на каждый из них может зависеть от следующих факторов:

- насколько хорошо инженер-программист знаком с
бизнес-областью;
- прецедент для такого типа программного обеспечения;
- степень риска (например, вероятность, серьезность) неправильных требований;
- ожидаемая текучесть кадров в течение
срока службы программного обеспечения;
- географическое распределение членов команды разработчиков;
- вовлечение заинтересованных сторон в течение проекта;
- предполагается ли использование комплексного решения или библиотеки с открытым исходным кодом;
- будет ли передан на аутсорсинг какой-либо проект или конструкция;
- ожидается ли степень тестирования на основе требований;
- потребуются ли усилия для использования метода спецификации кандидатов;
- требуется точность оценок, основанных на требованиях;
- необходимо проследить степень соответствия требованиям, если таковые имеются;
- договорные условия в отношении содержания и формата спецификации требований.

Как указано во введении к данному КА, требования к программному обеспечению, предъявляемые к проекту, должны определяться характером создаваемого программного обеспечения, а не жизненным циклом, в рамках которого оно создается. Последующие разработчики не должны быть в состоянии отличить жизненный цикл, использованный в более ранней разработке, только по форме этих требований. Влияние выбранного жизненного цикла должно быть ограничено полнотой требований на любом этапе проекта. В рамках поэтапного жизненного цикла ожидается, что требования будут полностью определены в конце этапа разработки требований. Ожидается, что в рамках гибкого жизненного цикла требования будут постоянно меняться, расти или устраняться, и не будут выполнены до завершения проекта.

В некоторых организациях существует культура документирования требований, в других - нет. Динамичные стартап-проекты часто основаны на четком видении продукта и ограниченных ресурсах; их команды могут рассматривать документирование требований как ненужную нагрузку. Но по мере развития и доработки этих продуктов инженеры-программисты часто осознают, что им необходимо восстановить требования, которые определяли особенности продукта, чтобы оценить влияние предлагаемых изменений. Следовательно, документирование требований и управление изменениями становятся важными факторами долгосрочного успеха. Подход проекта к требованиям в целом и к спецификации требований в частности может меняться в течение срока службы программного обеспечения.

Основная рекомендация при составлении документации по требованиям заключается в том, чтобы принимать решения на основе анализа аудитории. Кто такие различные потребители, которым потребуется информация из спецификации требований? Какая информация им понадобится? Как можно упаковать и представить эту информацию таким образом, чтобы каждый потребитель мог получить необходимую ему информацию с наименьшими усилиями?

Между анализом требований и спецификацией существует определенная степень совпадения и зависимости. Использование определенных методов спецификации требований, в частности спецификаций требований на основе моделей, позволяет проводить анализ требований, который может выходить за рамки того, что уже было представлено.

К документированным требованиям к программному обеспечению должны применяться те же методы управления конфигурацией, что и к другим конечным результатам процессов жизненного цикла программного обеспечения. (Подробное обсуждение приведено в разделе <a href="/8_Software Configuration Management.markdown">"Управление конфигурацией"</a>). Кроме того, при необходимости индивидуальные требования также могут быть изменены с помощью управления конфигурацией, которое обычно поддерживается инструментом управления требованиями. (см. раздел <a href="#8-инструменты-для-определения-требований-к-программному-обеспечению-software-requirements-tools">8 Инструменты для определения требований к программному обеспечению</a>).

Существует несколько общих категорий методов определения требований, каждый из которых рассмотрен ниже. В спецификации требований для данного проекта также могут использоваться различные методы. Стандарты ISO/IEC/IEEE 29148  и многие другие предлагают шаблоны для документации по требованиям.

#### 4.1 Спецификация требований к неструктурированному естественному языку (4.1.Unstructured Natural Language Requirements Specification)

Спецификации требований к естественному языку выражают требования на обычном языке. Спецификации требований к естественному языку могут быть неструктурированными или структурированными.

Типичная спецификация требований к неструктурированному естественному языку представляет собой набор утверждений на естественном языке, таких как “Система должна...” Например, бизнес-правила - это утверждения, которые определяют или ограничивают некоторые аспекты структуры или поведения бизнеса, подлежащие автоматизации. “Студент не может записаться на курсы в следующем семестре, если у него осталась неоплаченная плата за обучение” - это пример бизнес-правила, которое служит требованием к университетскому программному обеспечению для регистрации курсов. Некоторые проекты могут публиковать руководство пользователя в качестве удовлетворительной спецификации требований, хотя эффективность этого может быть ограничена.

#### 4.2 Спецификация требований к структурированному естественному языку (Structured Natural Language Requirements Specification)

Спецификации требований к структурированному естественному языку накладывают ограничения на способ выражения требований; цель состоит в повышении точности и краткости.

Простейшим примером может служить формат "субъект-действие". Субъект - это объект, ответственный за выполнение действия, а действие - это то, что должно произойти. Инициирующее событие может предшествовать субъекту, а за действием может следовать необязательное условие или квалификация. Утверждение “При отправке заказа система должна создать счет-фактуру, если только условия заказа не являются ”предоплаченными"", использует формат "субъект-действие". Инициирующим событием является “Когда заказ отправлен”. Субъектом является “система". Действие - ”создать счет-фактуру". Условие/оговорка - “за исключением того, что условия заказа являются "предоплаченными".”

Другим примером является шаблон спецификации варианта использования, как показано в таблице ниже

|||
|-|-|
|Пример использования №66|Название варианта использования: Резервирование рейса|
|Инициирующее событие|Клиент запрашивает бронирование на рейс|
|Параметры|Пассажир, маршрут, класс тарифа, способ оплаты|
|Запросы|Законный маршрут, соблюдены ограничения по классу тарифа|
|Гарантии|Листы, зарезервированные для пассажира на маршруте полета|
|Обычный курс|Пассажир, не являющийся пассажиром категории ff, все внутренние рейсы, эконом-класс, кредитная/дебетовая карта|
|Альтернативный курс|Является ли пассажир FF: [Нет, Серебряный, Золотой, Платиновый, Элитный <br>Маршрут: [Все международные, смешанные внутренние и международные рейсы]<br>Класс тарифа: [Базовый эконом, Премиум Эконом, Бизнес, Первый]<br>Способ оплаты: [Ваучер, мили FF]|
|Исключения|Карта C/D отклонена, ваучер не существует, срок действия ваучера истек, счет FF не существует, недостаточно миль на счете FF|

<br>
Другими примерами являются формат пользовательской истории “Как <пользователь> Я хочу
<возможности>, чтобы <получить выгоду>”, а также таблицы решений.

#### 4.3 Спецификация требований, основанная на критериях приемлемости (Acceptance Criteria-Based Requirements Specification)

Этот общий подход включает в себя два конкретных варианта: разработку на основе приемочного тестирования (ATDD) и разработку на основе поведения (BDD).

ATDD является частью более широкого подхода к разработке на основе тестирования (TDD). (см. раздел <a href="/5_Software Testing.markdown">"Тестирование программного обеспечения"</a>). Основная идея TDD заключается в том, что тестовые примеры предшествуют созданию. Таким образом, новый производственный код не пишется и существующий код не модифицируется до тех пор, пока хотя бы один тестовый пример не завершится неудачей либо на уровне модульного тестирования, либо на уровне приемочного тестирования. Процесс ATDD состоит из трех этапов:

1. Для реализации выбирается единица функциональности (например, история пользователя).

2. Один или несколько инженеров—программистов, один или несколько экспертов в области бизнеса и, возможно, один или несколько специалистов по контролю качества/тестированию встречаются — перед выполнением каких-либо работ по проектированию или конструированию - для согласования набора тестовых примеров, которые должны пройти, чтобы показать, что функциональная единица была реализована правильно.

3. At по крайней мере, один из этих приемочных тестов должен завершиться неудачей в существующем программном обеспечении. Наличие хотя бы одного неудачного тестового примера дает инженеру(ам) разрешение на создание или модификацию производственного кода для прохождения всех согласованных тестовых примеров. Этот шаг может потребовать нескольких итераций. На этом этапе код также может быть переработан.

Когда пройдены все приемочные тесты и, предположительно, все модульные и интеграционные тесты, считается, что функциональная единица была полностью и правильно реализована. Процесс ATDD возвращается к шагу 1, где выбирается новая функциональная единица, и цикл повторяется.

Может показаться, что ATDD - это скорее метод тестирования, чем метод спецификации требований. С другой стороны, тестовый пример имеет общую форму “При вводе данных, которые выглядят как X, мы ожидаем, что программное обеспечение выдаст результаты, которые выглядят как Y”. Ключевым моментом является подчеркнутая фраза “мы ожидаем, что программное обеспечение выдаст результаты”. Если мы просто изменим эту фразу так: “программное обеспечение должно выдавать результаты”, например, “При вводе данных, которые выглядят как X, программное обеспечение должно выдавать результаты, которые выглядят как Y”, то то, что сначала выглядело как тестовый пример, теперь выглядит как требование. Технически, один пример приемочного тестирования может включать в себя более одного требования, но общая идея заключается в том, что тестовые примеры ATDD по сути являются точными, недвусмысленными формулировками требований.

Подход BDD несколько более структурирован, и эксперты в бизнес-областях обычно предпочитают его ATDD, поскольку он менее техничен на вид. В BDD функциональная единица описывается как история пользователя в форме, подобной этой: “В качестве <роли> я хочу
<цель/желание>, чтобы получить <выгоду>.” Это приводит к определению и конкретизации набора “сценариев” в такой форме: “Учитывая <некоторый контекст> [и <возможно, больше контекста>], когда <стимул>, затем <результат> [и <возможно, больше результатов>]”.

Если история такова: “Как клиент банка, я хочу снять наличные в банкомате, чтобы получить деньги, не посещая банк”, то одним из сценариев может быть то, что “на счете имеется достаточный баланс”. Этот сценарий можно было бы описать следующим образом: “Учитывая, что баланс счета составляет 500 долларов, банковская карта клиента действительна, а в кассе банкомата достаточно денег, когда владелец счета запрашивает 100 долларов, банкомат должен выдать 100 долларов, а баланс счета должен составлять 400 долларов"., и банковская карта клиента должна быть возвращена”.

Другой сценарий может заключаться в том, что “на счете недостаточно средств”, и может быть описан следующим образом: “Учитывая, что баланс счета составляет 50 долларов, банковская карта клиента действительна, а в кассе банкомата достаточно денег, когда владелец счета запрашивает 100 долларов, банкомат запрашивает 100 долларов". не следует выдавать никаких денег, а банкомат должен сообщить о недостаточном балансе, остаток должен оставаться на уровне 50 долларов, и банковская карта клиента должна быть возвращена”.

Целью BDD является создание полного набора сценариев для каждой единицы функциональности. В ситуации со снятием наличных могут потребоваться дополнительные сценарии для “Банковская карта клиента Банка была отключена” и “В банкомате недостаточно денег в кассе”.

Примеры приемочных тестов очевидны из сценариев BDD.

Спецификация требований, основанная на критериях приемлемости, напрямую решает проблему неоднозначности требований. Естественные языки по своей сути неоднозначны, но язык тестовых примеров - нет. В спецификации требований, основанной на критериях приемлемости, требования написаны с использованием языка тестовых примеров, который является очень точным. С другой стороны, это по своей сути не решает проблему неполноты. Однако сочетание ATDD или BDD с соответствующими критериями охвата функциональным тестированием, такими как тестирование предметной области, анализ граничных значений и попарное тестирование (см. раздел <a href="/5_Software Testing.markdown">"Тестирование программного обеспечения"</a>), может снизить вероятность неполноты требований.

#### 4.4 Спецификация требований, основанная на модели (Model-Based Requirements Specification)

Другим подходом к устранению двусмысленности, присущей естественным языкам, является использование языков моделирования, таких как отдельные элементы Unified Modeling Language ™ (UML) или Systems Modeling Language ™ (SysML). Подобно чертежам, используемым при строительстве зданий, эти языки моделирования могут использоваться без использования компьютерных технологий для точного и лаконичного определения функциональных требований. Эта тема тесно связана с <a>моделями программного обеспечения</a> и <a>методами разработки программного обеспечения</a>. Модели требований делятся на две основные категории:

1. Структурные модели для определения политик, которые необходимо применять: это модели логических классов, описанные, например. Их также называют концептуальными моделями данных, логическими моделями данных и диаграммами сущностей-отношений.
2. Поведенческие модели для определения процессов, которые должны выполняться: Эти модели включают моделирование вариантов использования диаграммы взаимодействия и моделирование состояний. Другими примерами являются диаграммы действий на языке UML и моделирование потоков данных.

Спецификации требований, основанные на модели, различаются по степени формализации модели. Учесть следующее:

- Гибкое моделирование является наименее формальным. Гибкие модели могут быть не более чем грубыми набросками, целью которых является передача важной информации, а не демонстрация правильного использования обозначений при моделировании. В этом типе моделирования эффект от коммуникации считается более важным, чем форма коммуникации.
- Полуформальное моделирование содержит определение семантики языка моделирования, но формально не доказано, что это определение является полным и непротиворечивым.
- Формальное моделирование, например, Z, венский метод разработки (VDM), язык спецификаций и описаний (SDL) имеют очень точно определенную семантику, которая позволяет механически анализировать спецификации на наличие или отсутствие определенных свойств, что помогает избежать критических ошибок в рассуждениях. В этом контексте для разработки использовался термин "корректность по построению". (Смотрите раздел <a>"Формальные методы"</a> в разделе <a>"Модели и методы разработки программного обеспечения"</a>).

Как правило, чем более формальной является модель требований, тем менее она двусмысленна, поэтому разработчики программного обеспечения с меньшей вероятностью могут неправильно истолковать требования. Более формальные модели требований также могут быть:

- более краткими и компактными;
- их легче перевести в код, возможно, механически;
- используется в качестве основы для составления примеров приемочных испытаний.

Хотя формальные языки моделирования более эффективны, чем полуформальное и гибкое моделирование, формальные обозначения могут быть обременительными как для создателя модели, так и для читателей-людей. Компромисс Wing заключается в использовании формально определенных основ (например, в Z) для поверхностных синтаксисов, которые легче читать и записывать (например, диаграммы состояний UML).

#### 4.5 Дополнительные атрибуты требований (Additional Attributes of Requirements)

Помимо уже описанных основных требований, может оказаться полезным документирование дополнительных атрибутов для некоторых или всех требований. Эта дополнительная информация может помочь разработчикам программного обеспечения лучше интерпретировать требования и управлять ими. Возможные дополнительные атрибуты включают следующее:

- тег для поддержки отслеживания требований;
- описание (дополнительные сведения о требовании);
- обоснование (почему требование важно);
- источник (роль или имя заинтересованной стороны, которая ввела это требование);
- пример использования или соответствующее инициирующее событие;
- тип (классификация или категория требования — например, функциональность, качество обслуживания);
- зависимости;
- конфликты;
- критерии приемлемости;
- приоритет;
- стабильность;
- является ли требование общим или является вариантом для разработки семейства продуктов;
- вспомогательные материалы;
- история изменений требования.

Gilb's Planguage (сокращенно от Planning Language) рекомендует такие атрибуты, как масштаб, измеритель, минимум, цель, невыполненные задачи, прошлое, тенденция и рекорд.

#### 4.6 Дополнительные и всеобъемлющие требования; Спецификация (Incremental and Comprehensive Requirements Specification)

В проектах, которые явно документируют требования, используется один из двух подходов. Один из них можно назвать поэтапным уточнением. При этом подходе версия спецификации требований содержит только отличия — дополнения, модификации и удаления — от предыдущей версии. Преимущество такого подхода заключается в том, что он позволяет создавать меньший объем письменных спецификаций.

Другой подход можно назвать комплексной спецификацией. При таком подходе спецификация требований к каждой версии содержит все требования, а не только изменения по сравнению с предыдущей версией. Преимущество такого подхода заключается в том, что читатель может ознакомиться со всеми требованиями в одном документе вместо того, чтобы отслеживать совокупные добавления, изменения и удаления в ряде спецификаций.

Некоторые организации комбинируют эти два подхода, выпуская промежуточные версии (например, x.1, x.2 и x.3), которые уточняются постепенно, и основные версии (например, 1.0, 2.0 и 3.0), которые уточняются полностью. Читателю не нужно заглядывать дальше спецификаций требований к последнему крупному выпуску, чтобы получить полный набор спецификаций.

### 5 ПРОВЕРКА ТРЕБОВАНИЙ (REQUIREMENTS VALIDATION)

Проверка требований связана с получением уверенности в том, что требования отражают истинные потребности заинтересованных сторон в том виде, в каком они поняты на данный момент (и, возможно, задокументированы). Ключевые вопросы включают в себя следующее:

- соответствуют ли они всем требованиям, актуальным на данный момент?
- являются ли какие-либо заявленные требования несоответствующими потребностям заинтересованных сторон?
- правильно ли сформулированы эти требования?
- понятны ли они, последовательны и полны ли?
- соответствует ли документация по требованиям соответствующим стандартам?

Обычно используются три метода проверки требований: анализ требований, моделирование и выполнение, а также создание прототипов.

#### 5.1 Проверка требований (Requirements Reviews)

Наиболее распространенным способом проверки является просмотр или инспектирование документа с требованиями. Одного или нескольких рецензентов просят выявить ошибки, упущения, неверные предположения, отсутствие ясности и отклонения от принятой практики. Предпочтителен анализ с разных точек зрения:

- клиенты, заказчицы и пользователи проверяют, чтобы их желания и потребности были представлены полностью и точно;
- другие инженеры-программисты, имеющие опыт работы с техническими требованиями, проверяют, чтобы документ был понятным и соответствовал применимым стандартам;
- инженеры-программисты, которые будут заниматься архитектурой, проектированием или конструированием программного обеспечения, удовлетворяющего этим требованиям, проверяют, достаточно ли этого документа для поддержки их работы.

Предоставление экспертам контрольных списков, критериев качества или “определения выполненного” может помочь им сосредоточиться на конкретных аспектах спецификации требований. (см. <a>Обзоры и аудиты</a> в разделе <a>"Качество программного обеспечения"</a>)

#### 5.2 Моделирование и выполнение (Simulation and Execution)

Заинтересованные стороны, не имеющие технического образования, могут не захотеть тратить время на детальное изучение спецификации. Некоторые спецификации могут быть подвергнуты моделированию или фактическому выполнению вместо проверки человеком или в дополнение к ней. В той мере, в какой требования сформулированы формально (например, в спецификации, основанной на модели), инженеры-программисты могут самостоятельно интерпретировать эту спецификацию и “выполнять” ее. При наличии достаточного набора демонстрационных сценариев заинтересованные стороны могут быть уверены, что спецификация полностью и точно определяет их политику и процессы.

#### 5.3 Создание прототипа (Prototyping)

Если спецификация требований не имеет формы, допускающей прямое моделирование или выполнение, альтернативой может быть создание инженером-программистом прототипа, который конкретно демонстрирует некоторые важные аспекты реализации. Это демонстрирует интерпретацию инженером-программистом этих требований.

Прототипы могут помочь выявить предположения разработчиков программного обеспечения и, при необходимости, дать полезную обратную связь о том, почему они ошибочны. Например, динамическое поведение пользовательского интерфейса может быть лучше понято с помощью анимированного прототипа, чем с помощью текстового описания или графических моделей. Однако опасность создания прототипов заключается в том, что косметические недостатки или проблемы с качеством прототипа могут отвлечь внимание рецензентов от основной функциональности. Разработка прототипов также может быть дорогостоящей. Однако, если прототип помогает инженерам избежать потерь, вызванных попытками удовлетворить ошибочные требования, его стоимость может быть более оправдана.

### 6 МЕРОПРИЯТИЯ ПО УПРАВЛЕНИЮ ТРЕБОВАНИЯМИ (REQUIREMENTS MANAGEMENT ACTIVITIES)

Разработку требований в целом можно рассматривать как “достижение соглашения о том, какое программное обеспечение должно быть создано”. (см. рис. 1.3.) Напротив, управление требованиями можно рассматривать как “поддержание этого соглашения на протяжении долгого времени”. В этом разделе рассматривается управление требованиями.

#### 6.1 Требования к очистке (Requirements Scrubbing)

Цель анализа требований состоит в том, чтобы найти наименьший набор простых требований, который удовлетворит потребности заинтересованных сторон. Это позволит уменьшить размер и сложность решения, тем самым минимизируя усилия, затраты и сроки его реализации. Анализ требований включает в себя устранение требований, которые:

- выходят за рамки области применения;
- не принесут адекватной отдачи от инвестиций;
- не являются столь важными.

Другой важной частью процесса является упрощение излишне сложных требований.

В waterfall и других жизненных циклах, основанных на планировании, проверка требований может быть скоординирована с проверкой требований для валидации; проверка должна проводиться непосредственно перед проверкой валидации. В гибких жизненных циклах очистка происходит неявно при планировании итераций; в спринт (итерацию) включаются только требования с наивысшим приоритетом.

#### 6.2 Управление изменениями требований (Requirements Change Control)

Контроль изменений занимает центральное место в управлении требованиями. Этот раздел тесно связан с разделом <a href="/8_Software Configuration Management.markdown">"Управление конфигурацией программного обеспечения"</a>. (Обратитесь к этой главе для получения дополнительной информации).

Проекты, использующие каскадные или другие жизненные циклы, основанные на планировании, должны иметь четкий процесс контроля изменений требований, который включает в себя:

Требования к программному обеспечению 1-17

- средства запроса изменений к ранее согласованным требованиям;
- необязательный этап анализа воздействия для более тщательного изучения выгод и затрат, связанных с запрошенным изменением;
- ответственное лицо или группа, которые решают принять, отклонить или отложить каждое запрошенное изменение;
- средство уведомления всех заинтересованных сторон об этом решении;
- средство отслеживания принятых изменений до завершения.

Все заинтересованные стороны должны понимать и соглашаться с тем, что принятие изменений означает принятие их влияния на график, ресурсы и/или соответствующие изменения в масштабах других частей проекта.

В отличие от этого, в гибких жизненных циклах управление изменениями требований происходит неявно. В этих жизненных циклах любой запрос на изменение ранее согласованных требований становится просто еще одним элементом в списке невыполненных работ по продукту. Запрос становится “принятым” только в том случае, если его приоритет достаточно высок, чтобы превратить его в итерацию (спринт).

#### 6.3 Согласование области применения (Scope Matching)

Согласование объема работ предполагает обеспечение того, чтобы объем требований к архитектору, проектировщику и конструктору не превышал каких-либо ограничений по стоимости, графику или персоналу проекта. Когда объем требований превышает ограничения по затратам, графику или персоналу, то либо этот объем должен быть сокращен (предположительно, путем устранения достаточного количества требований с наименьшим приоритетом), либо необходимо увеличить пропускную способность (путем продления графика или увеличения бюджета и/или штата), либо необходимо согласовать некоторое подходящее сочетание этих факторов .

В waterfall и других жизненных циклах, основанных на планах, согласование области применения может быть согласовано с проверкой требований; согласование области применения должно происходить непосредственно перед проверкой. В гибких жизненных циклах, если какой-либо вариант спринта на основе скорости


планирование завершено, после чего в спринт/итерацию будет включена только та работа, выполнение которой можно обоснованно ожидать в течение этого спринта/итерации.

### 7 ПРАКТИЧЕСКИЕ СООБРАЖЕНИЯ (PRACTICAL CONSIDERATIONS)

#### 7.1 Итеративный характер процесса разработки требований (Iterative Nature of the Requirements Process)

Требования к типичному программному обеспечению не только широки по охвату, но и должны быть значительно более глубокими. Напряженность, возникающая из-за одновременных требований по охвату и глубине в реальных проектах, часто вынуждает команды выполнять работы с требованиями итеративно. В некоторых случаях выявление и анализ данных способствуют расширению круга знаний о требованиях, в то время как в других случаях требуется углубление знаний. На практике крайне маловероятно, что вся работа с требованиями может быть выполнена за один проход по предмету.

#### 7.2 Определение приоритетности требований (Requirements Prioritization)

Определение приоритетности требований полезно для всего программного проекта, поскольку оно помогает инженерам-программистам сосредоточиться на скорейшем предоставлении наиболее ценной функциональности. Это также помогает принимать разумные компромиссные решения, связанные с разрешением конфликтов и согласованием области применения. Приоритизированные требования также помогают в обслуживании, не ограничиваясь первоначальным проектом разработки. Дефекты, выявленные при выполнении требований с более высоким приоритетом, вероятно, следует устранять до того, как будут устранены дефекты, выявленные при выполнении требований с более низким приоритетом.

Существует множество схем расстановки приоритетов. Ответы на несколько ключевых вопросов могут помочь инженерам выбрать наилучший подход. Первый вопрос: “Какие факторы имеют значение при определении приоритета одного требования над другим?” Следующие факторы могут иметь значение для проекта:

- ценность; желательность; удовлетворенность клиента, заказчицы и пользователя;
- нежелательность; неудовлетворенность клиента, заказчицы и пользователя (модель Кано, ниже);
- стоимость доставки;
- стоимость обслуживания в течение срока службы программного обеспечения;
- технический риск внедрения;
- существует риск того, что пользователи не будут использовать его, даже если он будет внедрен.

Модель Кано, показывает, что рассмотрение только ценности, желательности или удовлетворенности может привести к ошибочным приоритетам. Лучшее понимание приоритетов достигается путем рассмотрения того, насколько недовольны были бы заинтересованные стороны, если бы это требование не было выполнено. Например, рассмотрим проект по разработке почтового клиента. К кандидатам могут предъявляться два требования:

1. Наличие эффективного спам-фильтра
2. Обработка вложений в электронных письмах

При расстановке приоритетов необходимо учитывать как удовлетворенность пользователей наличием определенных функций, так и неудовлетворенность, которую они испытают, если у них не будет определенных функций. Например, пользователи с большей вероятностью будут довольны эффективным спам-фильтром, чем возможностью обрабатывать вложения, поэтому спам-фильтру будет присвоен более высокий приоритет в зависимости от критерия удовлетворенности. С другой стороны, невозможность обрабатывать вложения сделала бы многих пользователей крайне недовольными — гораздо больше, чем отсутствие эффективного спам-фильтра. Когда речь заходит о счастье или удовлетворении от внедрения функций в сочетании с неудовольствием (или неудовлетворенностью) от того, что некоторые функции не были реализованы, разработчики, как правило, придают обработке вложений более высокий приоритет, чем эффективному фильтру нежелательной почты.

Второй ключевой вопрос: “Как мы можем преобразовать набор соответствующих факторов в выражение приоритета?” Формула

<div style="text-align:center">
<img src="Images/Chapter 1/Формула.bmp"
alt="формула"
width="300">
<br>
</div>

это всего лишь один из примеров целевой функции, позволяющей это сделать. Выбор схем измерения соответствующих факторов может накладывать ограничения на целевую функцию. (см. <a>Теорию измерений</a> в разделе <a>Основы вычислительной техники</a>).

После определения приоритетности требований эти приоритеты должны быть указаны таким образом, чтобы их можно было довести до сведения всех заинтересованных сторон. Для этого возможно несколько способов, в том числе следующие:

- шкала с перечислениями (например, must have, следует иметь, приятно иметь).;
- числовая шкала (например, от 1 до 10);
- Списки, в которых требования сортируются в порядке убывания приоритета.

Эффективная расстановка приоритетов требований направлена на поиск групп требований со схожими приоритетами, а не на создание чрезмерно строгих шкал измерений или обсуждение небольших различий.

#### 7.3 Отслеживание требований (Requirements Tracing)

Отслеживание требований может служить двум потенциально полезным целям. Одна из них заключается в проведении бухгалтерского учета, который документирует согласованность между парами связанных рабочих продуктов проекта. Важным вопросом может быть следующий: “Существуют ли определенные элементы дизайна, предназначенные для удовлетворения каждого выявленного требования к программному обеспечению?” Если идентифицированные элементы дизайна не могут быть найдены, то либо это требование не удовлетворяется в данном проекте, либо дизайн правильный, и одно или несколько заявленных требований могут быть удалены. Аналогично, “Для каждого идентифицированного элемента дизайна существуют ли определенные требования, которые обусловливают его существование?” Если идентифицированные требования не могут быть найдены, то либо этот элемент дизайна не нужен, либо заявленные требования являются неполными.

Другая цель состоит в том, чтобы помочь в анализе последствий предлагаемого изменения требований. Если, например, изменится конкретное системное требование, это системное требование можно будет проследить по связанным с ним требованиям к программному обеспечению. Не все связанные требования к программному обеспечению необходимо будет менять. Но каждое требование к программному обеспечению, которое может быть затронуто, может быть прослежено до связанных с ним элементов дизайна. Опять же, не все связанные элементы дизайна нужно будет менять.

Но каждый затронутый элемент дизайна может быть прослежен до связанного кода. Затронутые требования к программному обеспечению, элементы дизайна и блоки кода также могут быть прослежены до связанных с ними тестовых примеров для дальнейшего анализа влияния. Это помогает определить объем работы, необходимый для включения этого изменения в системные требования.

Требования к программному обеспечению можно проследить до исходной документации, такой как системные требования, документы стандартов и другие соответствующие спецификации. Требования к программному обеспечению также можно проследить до элементов проектирования и тестовых примеров, основанных на требованиях. Наконец, требования к программному обеспечению также можно проследить до разделов руководства пользователя, описывающих реализованные функциональные возможности.

#### 7.4 Требования к стабильности и непостоянству (Requirements Stability and Volatility)

Некоторые требования очень стабильны; вероятно, они никогда не изменятся в течение срока службы программного обеспечения. Некоторые требования менее стабильны; они могут меняться в течение срока службы, но могут и не измениться в ходе проекта разработки. Например, в банковском приложении требования к функциям для расчета и зачисления процентов на счета клиентов, скорее всего, будут более стабильными, чем требования к поддержке различных безналоговых счетов. Первое отражает фундаментальную особенность банковского домена (то, что на счетах могут начисляться проценты). В то же время, последние могут устареть из-за изменений в государственном законодательстве. Наконец, некоторые требования могут быть очень нестабильными; они могут изменяться в ходе проекта, возможно, не один раз. Полезно оценить вероятность того, что требование изменится за определенный промежуток времени. Выявление потенциально изменчивых требований помогает инженеру-программисту разработать дизайн, более устойчивый к изменениям.

#### 7.5 Измерение требований (Measuring Requirements)

С практической точки зрения может оказаться полезным иметь некоторое представление об объеме требований, предъявляемых к конкретному программному продукту. Это число полезно для оценки масштаба нового проекта разработки или изменения требований, а также для оценки стоимости задач разработки или технического обслуживания или просто для использования в качестве знаменателя при других измерениях. Измерение функционального размера (FSM) - это метод оценки размера совокупности функциональных требований.

Дополнительную информацию об измерении размера и стандартах можно найти в разделе <a href="/4_Software Construction.markdown">"Процесс разработки программного обеспечения"</a>.

Разработано множество показателей качества, которые можно использовать для определения связи между качеством спецификации требований к программному обеспечению и другими переменными проекта, такими как стоимость, приемка, производительность, график и воспроизводимость. Показатели качества для отдельных требований к программному обеспечению и документа спецификации требований в целом могут быть получены на основе желаемых свойств, рассмотренных ранее в разделе <a href="#31-анализ-основных-требований-basic-requirements-analysis">3.1 "Анализ основных требований"</a>.

#### 7.6 Качество и совершенствование процесса разработки требований (7.6. Requirements Process Quality and Improvement)

Этот раздел посвящен оценке качества и совершенствованию процесса разработки требований. Его цель - подчеркнуть ключевую роль процесса разработки требований в стоимости и своевременности программного продукта, а также в удовлетворенности клиентов. Кроме того, это помогает согласовать процесс разработки требований со стандартами качества и моделями совершенствования процессов для программного обеспечения и систем. Качество и совершенствование процессов тесно связаны как с контролем качества программного обеспечения, так и с процессом разработки программного обеспечения, который включает в себя следующее:

- охват процесса требованиями с помощью стандартов и моделей совершенствования процессов;
- показатели процесса требований и сравнительный анализ;
- планирование и внедрение улучшений;
- планирование и внедрение улучшений в области безопасности/CIA (конфиденциальности, целостности и доступности).

### 8 ИНСТРУМЕНТЫ ДЛЯ ОПРЕДЕЛЕНИЯ ТРЕБОВАНИЙ К ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ (SOFTWARE REQUIREMENTS TOOLS)

Инструменты, которые помогают разработчикам программного обеспечения справляться с требованиями к программному обеспечению, в целом делятся на три категории: инструменты управления требованиями, инструменты моделирования требований и инструменты создания функциональных тестовых примеров, как описано ниже.

#### 8.1 Инструменты управления требованиями (Requirements Management Tools)

Инструменты управления требованиями поддерживают различные действия, включая хранение атрибутов требований, отслеживание, создание документов и контроль изменений. Действительно, отслеживание и контроль изменений могут быть практичными только в том случае, если они поддерживаются каким-либо инструментом. Поскольку управление требованиями является основой надлежащей практики разработки требований, многие организации инвестировали в инструменты. Однако гораздо больше людей управляют своими требованиями более разрозненными и, как правило, менее удовлетворительными способами (например, с помощью электронных таблиц).

#### 8.2 Инструменты моделирования требований (Requirements Modeling Tools)

Как минимум, инструмент моделирования требований поддерживает создание, изменение и публикацию спецификаций требований на основе моделей. Некоторые инструменты расширяют это, предоставляя также статический анализ (например, синтаксическую корректность, полноту и согласованность). Формальный анализ требует, чтобы инструментальная поддержка была применима для чего-либо, кроме тривиальных систем, и инструменты, как правило, делятся на две категории: для доказательства теорем или проверки моделей. Ни в том, ни в другом случае доказательство не может быть полностью автоматизировано, а компетентность в формальных рассуждениях, необходимая для использования инструментов, ограничивает более широкий формальный анализ. Некоторые инструменты также динамически выполняют спецификацию (моделирование).

#### 8.3 Инструменты для создания функциональных тестовых наборов (Functional Test Case Generation Tools)

Чем более формально определен язык спецификации требований, тем больше вероятность того, что функциональные тестовые сценарии могут быть, по крайней мере, частично получены механическим путем. Например, преобразование сценариев BDD в тестовые сценарии не представляет сложности. Другой пример связан с моделями состояний. Положительные тестовые случаи могут быть получены для каждого определенного перехода в модели такого типа. Отрицательные тестовые случаи могут быть получены из комбинаций состояний и событий, которые не отображаются.

В самом общем случае такие инструменты могут генерировать только входные данные для тестовых примеров. Определить ожидаемый результат не всегда возможно. Может потребоваться дополнительная экспертиза в области бизнеса.